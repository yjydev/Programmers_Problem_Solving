## 명예의 전당(1)    

- 풀이   

```python   
def solution(k, score):
    answer = []
    board = []
    for s in score:
        if len(board) < k :
            board.append(s)
            board.sort(reverse=True)
        else :
            for i in range(len(board)):
                if board[i] < s:
                    board.insert(i,s)
                    break
                elif board[i] == s:
                    board.insert(i+1,s)
                    break
            board = board[:k]
        answer.append(min(board))
    return answer
```    

- 이번 문제는 1일부터 마지막날까지 출연한 가수들의 점수가 담긴 배열 `score`, 명예의 전당에 기록되는 점수의 개수 `k` 가 주어질 때,     
  
  매일 발표된 점수 중 최하위 점수를 배열에 담아 리턴하는 문제였다.     
  
- 우선, 명예의 전당에 표시되는 점수들을 담을 배열 `board` 를 빈 배열로 초기화하고, `score` 배열을 순회하며 점수를 `s`에 저장한다.    

- 그리고 명예의 전당에 표시되는 점수의 수가 `k` 보다 작으면 (`=len(board) < k`) 별다른 처리 없이 `board` 에 추가하고 정렬한다.   

- 만약, `k` 보다 크거가 같으면, 제일 낮은 점수는 밀려서 내려가게 되므로, `board`의 원소들을 순회하면서     
  
  현재의 점수 `s`보다 작은 점수가 있다면, `insert(i,s)` 로 해당 점수의 위치에 `s`를 삽입한다.       
  
  - `[100,20,10] => [150,100,20,10]`     
  
  현재의 점수 `s`와 같은 점수가 있다면, `insert(i+1,s)` 로 해당 점수의 다음 위치에 `s`를 삽입한다.         
  
  - `[100(1),20,10] => [100(1),100(2),20,10]`          

  현재의 점수 `s` 보다 작거나 큰 점수가 없다면, 무시한다.      
  
<br>     

- 점수를 찾기 위한 순회에서 해당하는 점수를 찾으면 `break`를 **반드시** 걸어야 한다!!     

  - 명예의 전당은 `k` 개의 점수까지만 표시되어야 하므로 점수를 찾은 이후엔 `board = board[:k]`로 제한 범위 내의 배열만 저장한다.    

- `score` 순회를 할 때마다 일련의 과정이 모두 끝나면, `min(board)` 로 그 날의 최하위 점수를 `answer`에 추가하고, 순회 종료 후 리턴하면     

  마무리 된다.    
  
<hr>   

- 이번 문제는 이전에 다른 기업의 코딩테스트에서 풀었던 문제와 비슷한 유형이었어서 손쉽게 풀 수 있었던 것 같다.   

- 명예의 전당에 표시되는 개수가 제한되어 있기 때문에, list의 limit 설정부분만 주의하면 손쉽게 해결할 수 있는 문제였다.   

- 앞으로는 좀 더 코드를 줄일 수 있는 방법은 없을지 한 번 고민해봐야겠다는 생각을 했다.   



  


  
  
