## 콜라 문제    

- 풀이   

```python    
def solution(a, b, n):
    answer = 0
    while n >= a:
        share = n // a
        benefit = share * b
        n = n - (a * share) + benefit
        answer += benefit
    return answer
```    

- 이번 문제는 빈 병 `a` 개를 가져가면 콜라 `b` 병를 주는 마트가 있을 때, `n` 개의 빈병을 가져다주면    
  
  총 몇 병의 콜라를 받을 수 있는지 리턴하는 문제였다.   
  
- 총 `n`개의 빈병을 `a` 개 씩 가져다주는 거고, `a` 개 미만이면 교환할 수 없는 거니까 `n >= a` 조건으로 `while` 반복문을 작성하였다.    

- 처음엔 나머지도 `rest` 변수에 담아서 다 따져봐야 하나 했는데, 어차피 `n` 을 조작할 거니까 더 간단하게 풀 수 있을 것 같아 제거하였다.   

- 만약, `n = 20, a = 2, b = 1` 이라면, 빈병 2개를 가져가면 콜라 1병을 주는것이므로 20개를 가져다주면 콜라 `(20/2)*1 = 10`병을 받는다.    
  
  즉, `(n // a) * b` 병의 콜라를 받는 셈이다.    
  
  - 여기서 `b` 도 고려해야한다는 것이 **이 문제의 핵심 포인트!!**      
    
    테스트 케이스들이 모두 `b = 1` 이어서 테스트 케이스로만 맞추려고 했다간 실제 채점에서 정답률 7%를 기록할 수 있다..     
    
- 그러므로 일단 `n` 을 `a` 로 나눈 몫을 `share` 변수에 담고, `share * b` 병의 콜라를 받는 것이므로 그 때 받는 콜라 수를     
  
  `benefit` 변수에 담는다.    
  
- 따라서 마트에 갖다준 빈 병의 수는 `a * share` 개이고, 받은 콜라 수는 `benefit` 병이므로    
  
  `n - (a*share) + benefit` 으로 `n` 을 갱신한다.    
    
- 마지막으로 문제에서 총 받은 콜라 수를 리턴하라고 했으므로 `answer` 변수에 `benfit` 의 합을 누적 계산하고 리턴하면 된다.     

<br>     

- 전반적으로 최근에 추가된 문제들이 level 1 같지 않게 까다로운 면이 있었는데, 이번 문제는 테스트 케이스의 함정에만 빠지지 않는다면   
  
  수월하게 풀 수 있는 문제였다.    
