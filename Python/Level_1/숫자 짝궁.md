## 숫자 짝궁   

- 풀이   

```python    

```      

- 이번 문제는 두 정수 `X`, `Y` 에서 공통으로 나타나는 정수들을 이용하여 만들 수 있는 가장 큰 수를 두 수의 짝궁이라고 하고      
  
  짝궁을 구해 리턴하는 문제였다.    
  
  - 만약, 짝궁이 없다면 (= 공통으로 나타나는 정수가 없다면) `-1` 을 리턴한다.    

  - 만약, 짝궁이 `0`으로만 이루어져있다면, `0`을 리턴한다.    


<br>    
<hr>    

- 다른 풀이 73.7% 정답률 (5가지 케이스 시간초과)       

```python    
def solution(X, Y):
    answer = ''
    li = []
    li_Y = list(Y)
    for x in X:
        if not li_Y:
            break
        if x in li_Y:
            li.append(x)
            li_Y.remove(x)
    if len(li) == 0:
        return '-1'
    else:
        li.sort(key=lambda x: int(x), reverse=True)
        answer += ''.join(li)
    return str(int(answer))
```    

- 일단 주어진 두 정수 `X`, `Y` 중 공통으로 나타나는 정수를 체크해나갈 정수를 하나 정해 `list`로 형변환하여 `li_Y` 변수에 담고,    
  
  공통으로 나타나는 정수를 담을 빈 배열을 `li` 변수에 담는다.   
  
- 그리고 2중 for 문을 돌리면서 `x` 가 `li_Y` 에 존재하는 수라면 공통 정수이므로 `li` 배열에 추가하고 `li_Y` 배열에선 제거한다.         

- 만약 `li_Y` 의 모든 원소가 제거되었다면 더는 순회할 필요가 없으므로 `break`를 걸어 반복문을 빠져나온다.   

- 반복문 종료 후엔, `li`의 길이가 0이라면 공통되는 정수가 없었다는 뜻이므로 바로 `-1`을 리턴한다.    

- 그렇지 않다면 `li` 배열의 원소들을 큰 순서대로 내림차순 정렬하여 `join` 함수로 문자열로 합친 후 `answer` 에 추가해주면 된다.        

- 다만, 0으로만 이루어졌을 경우 `0` 을 리턴해야하므로 `answer` 변수를 한번 정수형으로 변환하고 다시 문자열로 변환하면 확실하게    
  
  정답을 구할 수 있다.    
  
- 하지만, 처음에 2중 for문에서 1중 for 문으로 변경하고, `while` 문도 `sort` 내장 함수로 바꿨는데도 시간초과가 여전히 발생하여서     
  
  list를 조작하는 부분에서 효율성 문제가 발생하지 않았나 하는 생각이 든다.    
  
- 좀 더 시간을 줄일 수 있는 방법을 찾아봐야 할 것 같다.    

