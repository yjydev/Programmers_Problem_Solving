## 숫자 짝궁   

- 풀이   

```python    
def solution(X, Y):
    answer = ''
    for i in range(9,-1,-1):
        cnt_X = X.count(str(i))
        cnt_Y = Y.count(str(i))
        cnt = min(cnt_X, cnt_Y)
        if cnt:
            answer += str(i) * cnt
    if answer == '':
        return '-1'
    if answer[0] == '0':
        return '0'
    return answer
```      

- 이번 문제는 두 정수 `X`, `Y` 에서 공통으로 나타나는 정수들을 이용하여 만들 수 있는 가장 큰 수를 두 수의 짝궁이라고 하고      
  
  짝궁을 구해 리턴하는 문제였다.    
  
  - 만약, 짝궁이 없다면 (= 공통으로 나타나는 정수가 없다면) `-1` 을 리턴한다.    

  - 만약, 짝궁이 `0`으로만 이루어져있다면, `0`을 리턴한다.    

- 각 `X`, `Y` 에 대해서, 0이 `X` 에 몇개 `Y` 에 몇개 있는지, 1이 각각 몇개 있는지, ... 를 쭉 세고나면 개수의 최소값이     
  
  `X`, `Y` 가 갖고 있는 공통 개수가 되므로 `range(9,-1,-1)` 로 범위를 설정하여 9부터 0까지 순회를 돌며 `count` 내장함수로 카운트한다.        
  
  - 짝궁은 공통으로 나타나는 정수로 만들 수 있는 가장 큰 정수를 의미하므로 오름차순이 아닌 내림차순으로 9부터 순회를 돌아야     
    
    나중에 정렬없이 그대로 리턴해도 되어서 편하다.        
  
- 그 후 `min` 함수로 `cnt_X`, `cnt_Y` 중 최소값을 `cnt` 변수에 저장하고 만약 `cnt` 값이 0 이 아니라면 공통으로 존재한다는 뜻이니까    
  
  `answer` 에 현재 `i` 값을 `str()` 로 문자열 형변환하여 `cnt` 수 만큼 더해준다.      
  
  - `cnt` 가 2라면, `X`, `Y` 둘 다 최소한 i를 2개씩 갖고 있다는 뜻이므로 `answer` 에 `i`를 2개 덧붙인다.    

- 순회가 종료되면, `answer` 이 빈 문자열이면 짝궁이 없는 것이므로 `-1` 을 리턴하고,       
  
  내림차순으로 붙였음에도 첫 문자열이 `0` 이라면 `00` 이든 `000` 이든 결국 `0` 인 것이므로 `0`을 리턴한다.    
  
- 둘 다 아니라면 `answer` 을 리턴하는 것으로 마무리한다.    

<br>    

- 이번 문제는 파이썬을 막 배운 단계에서 오히려 더 잘 풀 수 있었을 것 같다는 생각이 드는 문제였다..     

- JS 로 level 2,3 문제들을 풀다 와서 그런건지 처음부터 너무 어렵게 생각했던 것 같고,     
  
  파이썬의 유용한 내장함수의 소중함을 다시 한 번 깨달을 수 있었다..      




<br>    
<hr>    

- 다른 풀이 73.7% 정답률 (5가지 케이스 시간초과)       

```python    
def solution(X, Y):
    answer = ''
    li = []
    li_Y = list(Y)
    for x in X:
        if not li_Y:
            break
        if x in li_Y:
            li.append(x)
            li_Y.remove(x)
    if len(li) == 0:
        return '-1'
    else:
        li.sort(key=lambda x: int(x), reverse=True)
        answer += ''.join(li)
    return str(int(answer))
```    

- 일단 주어진 두 정수 `X`, `Y` 중 공통으로 나타나는 정수를 체크해나갈 정수를 하나 정해 `list`로 형변환하여 `li_Y` 변수에 담고,    
  
  공통으로 나타나는 정수를 담을 빈 배열을 `li` 변수에 담는다.   
  
- 그리고 2중 for 문을 돌리면서 `x` 가 `li_Y` 에 존재하는 수라면 공통 정수이므로 `li` 배열에 추가하고 `li_Y` 배열에선 제거한다.         

- 만약 `li_Y` 의 모든 원소가 제거되었다면 더는 순회할 필요가 없으므로 `break`를 걸어 반복문을 빠져나온다.   

- 반복문 종료 후엔, `li`의 길이가 0이라면 공통되는 정수가 없었다는 뜻이므로 바로 `-1`을 리턴한다.    

- 그렇지 않다면 `li` 배열의 원소들을 큰 순서대로 내림차순 정렬하여 `join` 함수로 문자열로 합친 후 `answer` 에 추가해주면 된다.        

- 다만, 0으로만 이루어졌을 경우 `0` 을 리턴해야하므로 `answer` 변수를 한번 정수형으로 변환하고 다시 문자열로 변환하면 확실하게    
  
  정답을 구할 수 있다.    
  
- 하지만, 처음에 2중 for문에서 1중 for 문으로 변경하고, `while` 문도 `sort` 내장 함수로 바꿨는데도 시간초과가 여전히 발생하여서     
  
  list를 조작하는 부분에서 효율성 문제가 발생하지 않았나 하는 생각이 든다.    
  
- 좀 더 시간을 줄일 수 있는 방법을 찾아봐야 할 것 같다.    

- 아직 JS 로 푸는 방식이 익숙해서인지 파이썬 내장함수에 편리한 함수들이 많다는 것을 깜빡 잊고 있었다..     
  
  - 이번 문제에서도 각 숫자가 몇 개씩 있는지 카운트하려면 `count` 내장함수를 쓰면 됐는데, `filter` 로 필터링하거나    
    
    리스트에서 일치하는 걸 `remove` 하는 등 시간이 오래걸리는 방법들을 사용하느라 시간초과가 났었던 것이다.    
    
    
