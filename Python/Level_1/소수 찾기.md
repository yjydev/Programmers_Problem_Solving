## 소수찾기    

- 풀이 (정확성 56.3%)   

```python     
def solution(n):
    answer = 0
    for i in range(2,n+1):
        cnt = 0
        for j in range(2,(i//2)+1):
            if i % j == 0 :
                break
        else:
            answer += 1
    return answer
    
```    

- 소수 판별 방법은 여러가지 방법이 있겠지만, 제일 기초적으로 1부터 `n`까지 순회를 돌면서 `i`가 자기자신과 1을 제외하고      
  
  나누어 떨어지는 수가 없는지, 즉, 소수인지 2중 for문으로 판별해보았다.    
  
  - 2중 for문을 돌기 전에, 약수의 개수를 계산할 변수 `cnt` 를 0으로 초기화하고, 범위는 1부터 `i`의 절반까지만 돌면 되므로     
    
    해당 범위 내에서 나누었을 때, 나머지가 0인 수가 있을때마다 `cnt` 에 1을 추가한다.   
    
  - 2중 for문이 끝났을 때, `cnt`가 1이라면, 나누어 떨어진 수가 1밖에 없다는 뜻이므로     
    
    1과 자기자신을 제외하고 나누어떨어지는 수가 없다는 소수의 정의와 동의하여 `answer`에 1을 더한다.    
    
- 하지만 정답률과 효율성에서 문제가 있어 다른 방법을 생각해봐야할 것 같다.    
  
  - 오답이 나오던 이유는 범위 설정에서 이유를 찾았다.     
  
  - 애초에 1은 소수가 아니고, 문제에서도 n은 2이상이라고 했는데 `i`의 범위를 설정할 때 `(1, n+1)` 로 설정했었고, `j`도 마찬가지로    
    2부터가 아닌 1부터 범위를 설정했어서 틀렸었다.    
    
  - 범위를 2부터 설정하게 되면, 나누어떨어지는 수가 존재하면 안되므로 `i % j == 0` 이라면 `break`를 걸어주고,     
  
    `break` 없이 순회를 종료하면 `else` 분기를 타서 `answer` 에 1를 더해줬다.    
    
    - Python 에선 따로 `flag` 변수 사용 없이 `for - else` 문으로 `break` 유무를 판단할 수 있어 편한 것 같다고 생각했다.     
    
- 정답률을 해결하고 보니 시간초과가 발생하였고, 효율성 측면은 해결할 수 없을 것 같아 보다 더 효율적인 알고리즘을 활용하기로 했다.    
