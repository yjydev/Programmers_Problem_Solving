## 소수찾기    

- 풀이    

```python    
def solution(n):
    arr = [True] * (n+1)
    for i in range(2,int(n**0.5)+1):
        if arr[i] == True:
            for j in range(i+i, n+1, i):
                arr[j] = False
    return len([prime for prime in range(2,n+1) if arr[prime] == True])
```    

- 이번 문제는 2이상 1000000이하의 자연수 `n`이 주어질 때, 1부터 n까지의 소수의 개수를 리턴하는 문제였다.     

- 이번엔 효율성 판정도 있어서, 소수 판별의 대표적인 알고리즘이라고 할 수 있는 `에라토스테네스의 체`를 활용해보기로 했다.    

- 에라토스테네스의 체는 아래와 같은 방법으로 소수를 걸러낸다.    

  - `n`개의 True 값을 가진 배열을 생성한다. (True = 소수, 처음은 모두 소수라 가정)         
  
  - 2부터 n의 제곱근 값까지 순회를 돌면서, 만약 해당 값이 배열에서 `True` 라면, 해당값의 배수는 모두 `False` 값으로 변경한다.      

    - 어떤 수의 배수라는 이야기는 그 수를 약수로 갖는다는 이야기이므로 소수의 조건에 상충된다.    
    
    - 1은 모든 수의 약수이고 소수가 아니므로 2부터 순회를 돌아야한다.     

  - 순회를 모두 돌고 배열에서 True인 값들만 뽑아내면 `n 이하의 소수 배열` 이 완성된다.       

- 에라토스테네스의 체로 걸러진 값들을 `list comprehension` 을 활용하여 `arr[prime] == True` 조건문으로 배열로 만든다.     

- 그러면 소수인 배열이 완성된 것이므로 내장 함수인 `len()` 을 활용하여 배열의 길이 값을 리턴하면 마무리된다.     


</br>   
<hr>     


- 풀이 (정확성 56.3%)   

```python     
def solution(n):
    answer = 0
    for i in range(2,n+1):
        cnt = 0
        for j in range(2,(i//2)+1):
            if i % j == 0 :
                break
        else:
            answer += 1
    return answer
    
```    

- 소수 판별 방법은 여러가지 방법이 있겠지만, 제일 기초적으로 1부터 `n`까지 순회를 돌면서 `i`가 자기자신과 1을 제외하고      
  
  나누어 떨어지는 수가 없는지, 즉, 소수인지 2중 for문으로 판별해보았다.    
  
  - 2중 for문을 돌기 전에, 약수의 개수를 계산할 변수 `cnt` 를 0으로 초기화하고, 범위는 1부터 `i`의 절반까지만 돌면 되므로     
    
    해당 범위 내에서 나누었을 때, 나머지가 0인 수가 있을때마다 `cnt` 에 1을 추가한다.   
    
  - 2중 for문이 끝났을 때, `cnt`가 1이라면, 나누어 떨어진 수가 1밖에 없다는 뜻이므로     
    
    1과 자기자신을 제외하고 나누어떨어지는 수가 없다는 소수의 정의와 동의하여 `answer`에 1을 더한다.    
    
- 하지만 정답률과 효율성에서 문제가 있어 다른 방법을 생각해봐야할 것 같다.    
  
  - 오답이 나오던 이유는 범위 설정에서 이유를 찾았다.     
  
  - 애초에 1은 소수가 아니고, 문제에서도 n은 2이상이라고 했는데 `i`의 범위를 설정할 때 `(1, n+1)` 로 설정했었고, `j`도 마찬가지로    
    2부터가 아닌 1부터 범위를 설정했어서 틀렸었다.    
    
  - 범위를 2부터 설정하게 되면, 나누어떨어지는 수가 존재하면 안되므로 `i % j == 0` 이라면 `break`를 걸어주고,     
  
    `break` 없이 순회를 종료하면 `else` 분기를 타서 `answer` 에 1를 더해줬다.    
    
    - Python 에선 따로 `flag` 변수 사용 없이 `for - else` 문으로 `break` 유무를 판단할 수 있어 편한 것 같다고 생각했다.     
    
- 정답률을 해결하고 보니 시간초과가 발생하였고, 효율성 측면은 해결할 수 없을 것 같아 보다 더 효율적인 알고리즘을 활용하기로 했다.    
