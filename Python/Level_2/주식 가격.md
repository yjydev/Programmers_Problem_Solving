## 주식 가격    

- 풀이    

```python   
def solution(prices):
    answer = [0] * len(prices)
    for idx,p in enumerate(prices):
        for j in range(idx+1, len(prices)):
            if p <= prices[j]:
                answer[idx] += 1
            else:
                answer[idx] += 1
                break
    return answer
```    

- 이번 문제는 시간의 흐름에 따른 주식 가격 변동 상황이 `prices` 배열로 주어질 때,     
  
  각 주식 가격들이 몇 초동안 떨어지지 않았는지를 배열에 담아 리턴하는 문제였다.    
  
  - 예를 들어, `[2,3,3,1]` 이었다면, `[3,2,1,0]` 으로 `1초 시점의 2` `2초 시점의 3`, `3초 시점의 3` 모두  
    4초 때 `1`로 떨어지기 전까지 떨어지지 않았으므로 각각 `3,2,1 초` 간 유지되었고, 4초 때는 마지막이므로 0초간 유지된 것이다.    
    
- 이번 문제에서 유의할 점은 **몇 초간 떨어지지 않고 유지되었는가** 이기 때문에 바로 다음에 떨어지더라도 1초 동안은 유지한 셈이 된다.      
  
  즉, **3초 가격이 4초에 떨어지면 1초간 유지한 것이다.** 이 점을 명심하고 풀이하면 어려움없이 풀 수 있다.    
  
- 우선, 유지된 시간을 더해줄 배열 `answer` 을 모두 0으로 초기화하고, `prices` 배열을 순회한다.    
  
- 각 시점에 대해 미래 시점만 고려하면 되므로 2중 for문 범위의 시작을 `idx+1` 로 잡고, 이전 가격이 다음 가격보다 작으면,     
  
  즉, 떨어지지 않았으면 `answer[idx]` 에 +1을 해준다.    
  
- 만약 떨어졌다면, 그 시간동안은 유지한 셈이므로 `answer[idx]` 에 마찬가지로 +1을 해주고 `break` 를 걸어서 빠져나온다.   

- 순회가 종료되면 `answer` 을 리턴하며 마무리한다.    

<br>   

- 이번 문제는 가격이 떨어졌더라도 그 기간 동안엔 유지한 셈이 되므로 `else` 분기에서도 +1 을 한 다음에 break를 한다는 것만    
  
  유의하면 어려움은 없었다.   
  
- 그리고 확실히 배열 슬라이싱은 효율성 측면에서 좋지 않다는 것을 다시 한 번 깨달았다.   

  - 동일한 풀이에서 `prices[idx+1:]` 로 슬라이싱하면 시간초과가 발생하고 `range(idx+1, len(prices))` 로 범위를 설정하면    
    
    무사히 통과된다.   
    
 
