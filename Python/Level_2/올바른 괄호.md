## 올바른 괄호   
- 풀이   

```python   
def solution(s):
    stack = []
    for str in s:
        if str == '(':
            stack.append(str)
        else :
            if stack and stack[-1] == '(':
                stack.pop(-1)
            else:
                return False
    if stack :
        return False
    return True
```     

- 이번 문제는 `(` 과 `)` 로만 이루어진 문자열 `s` 가 짝이 맞는 괄호들인지 아닌지 리턴하는 문제였다.    

  - `(()) = True`      
  - `)()( = False`     
  - 위처럼 `(` 로 시작해서 `)` 로 닫혀야 한 쌍이다.     

- 그래서 괄호를 쌓을 스택을 `stack` 변수에 빈 배열로 초기화하고, `s` 를 `str` 변수에 하나씩 담아 순회돌며 살펴본다.    

- `str` 이 여는 괄호 `(` 라면 `stack` 에 추가한다.    

- `str` 이 닫는 괄호 `)` 라면, 아래 두 가지를 생각해봐야 한다.   

  1. `stack` 에 원소가 있고, 마지막 원소 `[-1]` 가 여는 괄호 `(` 인 경우    
  
     - `stack` 에 있는 여는 괄호 `(` 는 현재 `str` 에 담긴 닫는 괄호 `)` 와 짝이 되어 사라지므로 `pop` 으로 삭제한다.    

  2. `stack` 이 비어있는 경우               
    
     -  `str` 이 닫는 괄호인데 `stack` 이 비어있다면, 여는 괄호 `(` 가 없는데 닫으려는 상황이므로     
    
         짝이 맞지 않아 `False` 리턴 후 종료        
  
     - 참고로, 마지막 원소 `[-1]` 가 닫는 괄호 `)` 인 경우는 존재할 수 없다.   

- 순회가 종료되었는데 `stack` 에 원소가 남아있다면 짝이 맞지 않는 경우이므로 `False` 리턴    

- 예외처리에 아무것도 걸리지 않고 내려왔다면 모든 조건에 통과한 것이므로 `True` 를 리턴하며 종료한다.    


- 이번 문제는 레벨2치고 어렵지 않게 풀 수 있었다.    

- 다른 사람의 풀이를 보았을 때, `if - else` 문을 활용하는 것이 아니라 `try - except` 문을 활용하여 예외처리하기도 하던데,   
 
  그렇게 하는 방법도 익혀둬야겠다는 생각이 들었다.   
  
- 또한, `stack` 에 점점 쌓고 없애는 방법이 아니라 `( 이면 +1` , `) 이면 -1` 하는 방식으로      
  
  변수를 하나 설정하여 `변수 < 0` 이면 `False` 를 리턴하고 (일종의 백트래킹?)     
  
  순회끝난 이후엔 `변수가 0이면 True, 아니면 False` 를 리턴하는 방법도 봤는데 신박하고 더 효율적일 것 같단 생각이 들었다.    

