## 연속 부분 수열 합의 개수   

- 풀이   

```python   
def solution(elements):
    res = [sum(elements)]
    li = elements * 2
    cnt = len(elements)
    for i in range(1,cnt):
        for k in range(cnt):
            res.append(sum(li[k:k+i]))
    return len((set(res)))
```   

- 이번 문제는 주어지는 수열 `elements` 가 원형 수열일 때, 연속 부분 수열을 만들 수 있는 경우의 합을 모두 구하여   
  
  그 합의 개수를 리턴하는 문제이다.    
  
- 원형 수열이라고 하면, `[1,2,3]` 이라는 수열이 있을 때, `[1,2,3, 1,2,3]` 처럼 3 다음에 끝이 아니라 처음의 1과   
  
  연결이 되는 것다.   
  
- 그러므로 연속 부분 수열을 구하기 위해서 일단 문제에서 주어진 수열 `elements` 를 2번 반복하여 늘리고 `li`에 저장한다.      

- 연속 부분 수열들의 합을 저장할 배열을 `res` 로 만들고, 초기 원소로 `elements` 의 합을 넣는다.   

  - 연속 부분 수열은 길이가 얼마냐에 따라 다르게 구성되겠지만, 길이가 `len(elements)` 인 수열은 자기 자신밖에 없으므로    
    
    사전에 미리 저장한다.    
    
- 이후 1부터 `len(elements)` 까지 `i`에 저장하고, 0부터 마지막 인덱스 `(len(elements) -1)` 까지를 k에 저장하며 순회를 돈다.   
  
  - `i` = 연속 부분 수열의 길이      
  - `k` = 연속 부분 수열의 시작 인덱스      

- `li` 배열을 `k` 부터 `k+i` 까지 슬라이싱하고, 그 합을 `sum()` 함수로 구하여서 `res`에 추가(`append`)` 한다.    

- 중복 제거된 개수를 구해야하므로 `set` 으로 형변환하여 중복 제거하고, `len()` 으로 길이를 구하여 리턴하면 마무리된다.   

<hr>   

- 이번 문제도 문제 이해만 되고, `i`, `k` 등의 길이와 시작 인덱스 범위 설정만 틀리지 않는다면 어렵지 않게 풀 수 있는 문제였다.  

- 바로 생각나는 풀이로 푼 문제인데, 몇 테스트 케이스에선 `3000ms` 즈음의 속도가 나오는 것 같아서, 개선시킬 수 있는 방법이   
  
  있나 한 번 고민해봐야 할 것 같다.   
  
  
