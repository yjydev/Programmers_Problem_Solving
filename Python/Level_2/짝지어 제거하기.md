## 짝지어 제거하기    

- 풀이   

```python    
def solution(s):
    stack = []
    for alpa in s:
        if stack and (stack[-1] == alpa):
            stack.pop()
        else:
            stack.append(alpa)

    return 0 if stack else 1
```    

- 이번 문제는 알파벳 소문자로 이루어진 문자열 `s` 가 주어질 때, 같은 알파벳 2개가 붙어있는 짝끼리 제거하고      
  
  앞뒤로 문자열을 이어붙이는 과정을 반복하는데, 모두 짝을 이루어 제거되면 1을, 아니라면 0을 리턴한다.             
  
- 문제 해결을 위해선, 문자열 `s` 를 순회돌며 짝이 없는 원소를 `stack` 에 하나씩 담고 현재 원소와 `stack` 의 마지막 원소를 비교해서   
  
  짝이 이루어지면 `stack` 의 마지막 원소를 제거하는 방식으로 진행하면 된다.    
  
- 비교할 문자열, 짝이 없는 문자열을 담을 배열 `stack` 을 빈 배열로 초기화한 후, 문자열 `s`의 각 원소를 `alpa` 변수에 담아 순회한다.   

- 비교할 문자열이 있고(=`stack`에 원소 존재), `stack` 의 마지막 원소가 현재 문자 `alpa` 와 같다면, 짝을 이룬 것이므로 `pop` 으로 제거한다.    

  - 첫 원소는 비교할 문자열이 없으므로 자연스레 `stack` 에 추가된다.    
  
- 그게 아니라 비교할 문자열이 없거나(=`stack`에 원소 없음), `stack`의 마지막 원소가 현재 문자 `alpa` 와 다르다면    
  
  짝이 아니므로 `stack` 에 `append` 로 추가한다.      
  
- `s` 의 순회가 끝난 이후에 `stack` 에 원소가 남아있다면 짝이 없는 알파벳이 있는 것이므로 `0`을 리턴하고,    
  
  `stack` 이 비어있다면 `1` 을 리턴하며 마무리한다.    
  
  
<br>   
<hr>    

- 이번 문제는 풀고나니 쉬웠지만, 왠지 모르게 처음에 이것저것 헤맸던 문제였다.   

- 문제 접근 방식은 현재 풀이나 이전 풀이나 다를 건 없지만,      
  
  시간초과가 발생했던 걸 보면 함수를 쓰는 방식이나 효율성 측면에서 제대로 고려를 못했던 것 같다.       
  
  
