## 기능 개발   

- 풀이   

```python    
import math
def solution(progresses, speeds):
    answer = []
    cnt, current = 1, 0
    for p,s in zip(progresses, speeds):
        day = math.ceil((100-p) / s)
        if day <= current:
            cnt += 1
        elif current != 0:
            answer.append(cnt)
            cnt = 1
        current = max(current, day)
    answer.append(cnt)
    return answer
```    

- 이번 문제는 각 기능의 진도가 100% 일 때만 배포가 진행되는 상황에서 작업의 진도가 적힌 배열 `progresses` 와      
  
  작업의 개발 속도가 적힌 배열 `speeds`가 주어질 때, 각 배포마다 몇 개의 기능이 배포되는지 배열에 담아 리턴하는 문제였다.    
  
  단, 앞 순서 작업이 종료되지 않았다면 뒷 순서 작업의 개발이 끝났더라도 기다렸다가 앞 순서 작업 종료시점에 한 번에 배포해야 한다.      
  
  - 예를 들어, `progresses = [93, 30, 55]`, `speeds = [1, 30, 5]` 이라면,     
    
    1번 작업은 남은 작업이 7% 에 속도가 1% 이므로 총 `7일` 소요되고,     
    
    2번 작업은 남은 작업이 70% 에 속도가 30% 이므로 총 `3일` 소요되고,    
    
    3번 작업은 남은 작업이 45% 에 속도가 5% 이므로 총 `9일` 소요된다.       
    
    그러므로 `7일 째` 에 첫 배포가 진행되고 1번과 2번 작업이 배포된다. 이후 `9일 째` 에 두 번째 배포가 진행되고 3번 작업이 배포된다.    
    
    따라서 `[2,1]` 을 리턴하면 된다.     
    
- 우선, 정답을 담을 배열을 `answer` 변수에 담아 빈 배열로 초기화한다.    

- 그리고 배포될 기능의 개수를 변수 `cnt`에 담아 1로 초기화하고, 배포 기간을 변수 `current`에 담아 0으로 초기화한다.    
  
  - 배포 기간이 언제가 되더라도 최소한 첫 배포에 1개의 기능은 배포할 것이므로 1로 초기화한다.    

- 그러면 준비가 끝났으므로 `zip` 함수로 진도 배열 `progresses` 과 속도 배열 `speeds` 을 한 번에 순회한다.     

- 순회하면서 소요 시간을 계산하기 위해 남은 작업 `(100 - p) %` / 개발 속도 `(s)` 를 하고, `math` 모듈의 올림 함수 `ceil`로 올림한다.    

  - 남은 작업이 70% 인데 속도가 30% 라면 몫은 2이지만, 나머지가 있어 1일을 더 소요하게 되므로 올림이 필요하다.    

- 계산한 값을 `day` 변수에 담고, 소요 시간(`day`)이 배포 기간(`current`)보다 적다면,    
  
  즉, 앞 기능이 완료되기 전에 작업이 끝난다면 같이 배포되는 기능이므로 `cnt` 에 `+1` 을 한다.     

- 그렇지 않다면 `answer` 배열에 현재 기능 개수 `cnt` 를 `append` 하는데, 주의할 점은 `current` 가 0이 아닌 경우에만 진행해야 한다.   
  
  - `current`가 0이라는 이야기는 첫 작업이라는 이야기이므로 아직 `answer` 배열에 추가하면 안된다.   

- 이후 `current` 변수를 `day`와 `current` 의 최대값으로 갱신하며 순회를 이어간다.    

- 순회가 종료되면, 마지막 배포를 위해 `answer` 배열에 현재 기능 개수 `cnt` 를 `append` 한 후, `answer` 를 리턴하면 종료된다.    

<br>    
<hr>   

- 이번 문제는 문제 설명만 잘 이해했다면 전반적으로 어렵지 않은 문제였다.    

- 올림 함수를 직접 구현하려다보면 코드가 괜히 길어질 것 같아서 이번엔 그냥 `math` 모듈을 활용했는데, 좀 더 간단하게 구현할 수 있는    
  
  방법은 없을지 더 고민해봐야 할 것 같다.    
  

    
 
