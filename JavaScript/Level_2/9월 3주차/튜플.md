## 튜플   
- 풀이   

```javascript    
function solution(s) {
    var answer = [];
    var tmp_arr = s.slice(1,-1);
    var tuple = tmp_arr.split('{').map((x) => {
        var end = x.indexOf('}');
        var tmp = x.substring(0,end);
        return tmp.split(',');
    });
    tuple.sort((a,b) => {return a.length - b.length});
    for (var k = 1; k < tuple.length; k++) {
        if (answer) {
            var diff = tuple[k].filter((x) => !answer.includes(x));
            answer.push(...diff);
        } else {
            answer.push(tuple[k]);
        }
    }
    return answer.map((x) => parseInt(x));
}
```    
- 이번 문제는 중복되는 원소가 없는 튜플을 표현하는 집합이 담긴 문자열 `s`가 주어질 때,    
  `s`가 표현하는 튜플을 배열에 담아 리턴하는 문제였다.       
  
- 일단, 문자열로 주어진 `s`를 파싱하여 집합을 배열로 변환하는 것이 첫 번째 관문이었다.    

- 이를 위해서, 아래와 같이 진행하였다.    
  
  1. 집합이 `{ {a}, {a,b} , ... }` 처럼 주어지는데, 처음과 마지막의 집합기호는 전체에 대한 것이라 필요 없으므로     
    `slice(1, -1)` 메서드로 자른다. (`slice` 메서드는 -1 같은 음수인덱스가 허용된다.)          
  
  2. 집합을 여는 기호인 `{` 을 기준으로 `split` 하면 `a},` , `a,b},` ... 처럼 분리된다.    
  
  3. 그렇게 분리된 각 원소들을 `map` 메서드를 활용하여 집합을 닫는 기호인 `}`의 인덱스를 찾아 `end` 변수에 담고,    
      `substring(0,end)` 메서드로 자르면 `a`, `a,b` , ... 와 같이 정리할 수 있다.    
  
  4. 마지막으로 `split(',')` 메서드로 분리하면 성공적으로 집합을 배열로 변환할 수 있다.    

- 파싱 완료된 배열을 `tuple` 변수에 담는다.    

- 이제 어떤 튜플을 표현하고자 한 것인지 찾아야 하는데, `(a,b,c,d)` 이라는 튜플에 대해서 아래와 같이 표현할 수 있다.   
  
  - `{ {a}, {a,b}, {a,b,c}, {a,b,c,d} }`     
  - `{ {c,b,a}, {a}, {b,a,c,d}, {b,a} }`    
  - 등등 집합은 원소의 순서가 바뀌어도 교환법칙에 의해 동일한 것이므로 다양하게 표현 가능하다.     

- 여러 방법으로 표현할 수 있긴 하지만, 1개 => 2개 => 3개 => ... => n개 로 점점 하나씩 증가시키는 것은 동일하다.     

- 그러므로, `tuple.sort((a,b) => {return a.length - b.length})` 로 각 원소의 길이에 따라 오름차순으로 정렬한다.      

- 이제 `tuple`의 각 원소를 필터링해서 튜플의 원소를 담을 배열 `answer`에 담으면 마무리 된다.        

- `answer`이 빈배열이라면, 다른 변환없이 바로 `answer`에 `push` 한다.     

- `answer`이 빈배열이 아니라면, `filter` 메서드로 `answer` 배열에 없는 원소들만 필터링해서 `answer`에 `push` 한다.    

  - `{a}, {a,b}, {a,b,c}, ...` 처럼 점차 새로운 원소가 추가되므로   
    `{a,b,c}` 를 넣을 차례엔 `answer`에 `a,b`가 이미 있는 상태인 것이다.      
    
  - 참고로, 필터링한 원소들을 넣을 땐 스프레드 연산자 `...`를 활용하여 `answer.push(...diff)` 처럼 풀어서 넣어야 한다.    

- 마지막으로 지금까진 계속 문자열을 조작한 것이므로 `answer` 배열을 리턴하기 전에 `map` 메서드로     
  
  각 원소에 대해 `parseInt` 변환을 진행한다.    
  
- 처음에 집합을 배열로 변환하는 것만 무사히 마친다면, 나머지 규칙들은 쉽게 생각해낼 수 있는 것들이었으므로 어려운 문제는 아니었다.    

- 다 풀고나서 알았는데, 문자열로 주어진 `s` 를 처음부터 `json` 형식으로 생각하여 `JSON.parse` 를 활용했다면      
  좀 더 수월하게 풀 수 있었으리란 생각이 들었다.        
  
- 또한, 마지막에 `tuple` 의 원소들을 `answer`에 담으려고 할 때,     
  
  `answer` 배열을 배열이 아니라 `Set`을 활용했다면 어땠을까하는 생각도 들었다.       
  
- 이러한 부분들을 추후 리팩토링할 때 활용하여 좀 더 효율적인 코드를 짤 수 있도록 노력해봐야겠다.     

