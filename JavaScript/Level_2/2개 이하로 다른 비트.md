## 2개 이하로 다른 비트    
- 풀이    

```javascript     
function solution(numbers) {
  var answer = [];
  for (n of numbers) {
    // 짝수라면 마지막이 무조건 0으로 끝나므로 +1 해주면 마지막 0이 1로 바뀌면서 
    // 1개만 다른 비트가 완성.
    // ex> 2 = 0010, 3 = 0011 / 16 = 10000, 17 = 10001
      if (n % 2 === 0) {
          answer.push(n+1);
      }
      // 홀수인 경우엔 여러번 직접 해보면서 규칙 찾기 
      // ex> 9 = 1001 , 10 = 1010 / 11 = 1011 , 13 = 1101 / 
            // => 9와 19은 마지막 01이 10으로 바뀌었고, 
            //    11과 13은 2~3번째 01이 10으로 바뀌었다. 
      // 15 = 1111 , 23 = 10111 / 21 = 10101, 22 = 10110 
            // => 15와 23의 경우엔 15 맨 앞에 0이 있다고 치면 맨 앞 01이 10으로 바뀌었다. 
            //    21과 22는 맨 마지막 부분의 01이 10으로 바뀌었다. 
      // 즉, 제일 끝에 나오는 01을 10으로 바꾸어주면 된다. 
      // indexOf가 아닌 lastIndexOf를 사용하는 이유는 최소값이기 때문인데 (= 2진수는 오른쪽으로 갈수록 작으므로), 
      // indexOf이면 21의 경우에 11001 로 25가 되기 때문이다.
      else {
          var bit = n.toString(2);
          var idx = bit.lastIndexOf('01');
      // 홀수는 마지막이 무조건 1로 끝나므로 01이 아닌 0을 찾아도 무관하다.
          // var idx = bit.lastIndexOf('0');
          var res = idx === -1 ? '10' + bit.substring(1) 
                      : bit.substring(0, idx) + '10' + bit.substring(idx+2)
        // 01을 못찾았다면 (-1 이라면), 1로만 이루어진 것이므로 앞에 0이 있다고 생각하고 111.. 을 1011.. 로 변경 
          // 즉, 맨 앞의 1를 떼버리고 대신 10을 붙이면 된다.
        // 01을 찾았다면, 0번부터 시작 idx 까지 자르고 대신 10을 붙이고 시작 idx +2번부터 다시 뒤에 붙이면 된다. 
        // substring은 인덱스가 문자열 길이를 넘어가면 알아서 마지막이라고 판단하기 때문에 길이는 신경안써도 ok  
          answer.push(parseInt(res,2));
        // 비트 계산 때문에 문자열이므로 다시 숫자로 바꿔서 answer 배열에 넣어준다.
      }
  }
  return answer;
}
```      
- 이번 문제는 함수 f(x)에 대한 정의가 주어질 때, 배열 numbers 의 각 값들에 대한 f(x) 값을 배열로 출력하는 문제였다.     
  - 함수 f(x)는 x보다 크고, x 와 1개 혹은 2개의 비트만 다른 수들 중 가장 작은 수이다.      

- 비트가 나왔으므로 숫자를 2진수(비트)로 변환하기 위해서, javascript에서 제공하는 `toString(2)` 를 활용하였다.    
  - 다만, 10진수 숫자를 2진수 비트 문자열로 바꾸는 방법이므로 추후 다시 10진수 수로 변환하는 과정 추가 필요    

- 일반적으로 2진수로 변환하는 방법은, 해당 수를 2로 계속 나누면서 나머지를 왼쪽으로 계속 붙여나가는 것이다.     
  - 첫번째로 나온 나머지가 제일 오른쪽끝이고, 왼쪽으로 계속 붙여나가는 것이므로    
    홀수일땐 무조건 1로 끝나고, 짝수일 땐 무조건 0으로 끝난다는 것을 알 수 있다.      
    
- 2진수는 짝수일 때와 홀수일 때 위와 같은 차이점이 있으므로 두가지 경우를 나눠서 생각해볼 수 있다.     

- 짝수일 땐, 제일 오른쪽 끝의 0을 1로 바꿔주면 `10 (2)` 에서 `11 (3)` 이 되는데, 이런 경우가    
    비트가 1개가 다르므로 함수 f(x) 의 정의를 만족하는 수라고 할 수 있다.    
  - 즉, 짝수일 땐 `+1` 만 하면 된다.    

- 홀수일 땐, 짝수일 때처럼 오른쪽 끝의 0을 1로 바꾸는 방법은 더 작아지기 때문에 사용할 수 없다.     
  그러므로 다른 규칙을 찾아야 하는데, 그러기 위해선 몇 가지 예시들을 살펴볼 필요가 있다.    
  
  - 위의 코드 주석에서 살펴본 것 처럼, 홀수일 땐 가장 오른쪽에 있는 `01` 을 `10`으로 바꾸면    
    비트가 2개 다르므로 조건을 만족할 수 있다.     
    
  - 그러므로 `01`을 찾아서,       
    해당 인덱스 `idx` 앞까지 `substring` 메서드로 자르고,        
    `10` 을 붙이고,      
    '10' 만큼 추가됐으므로 `idx + 2` 부터 끝까지 잘라서 합치면 완성이다.      
    
  - 다만, `111 (7)` 같은 수라면 `01`을 못찾을 수도 있는데, 이럴 땐 맨 왼쪽에 `0`이 생략되었다고 본다.     
  
    - 그렇게 되면, 맨 왼쪽의 `1`을 잘라내고, `10`을 붙이면 된다.    
      `0111 (7)` => `1011 (11)`      
      
 - 마지막엔 `parseInt(비트, 2)` 메서드를 활용하여 2진수 문자열을 다시 int 형 10진수 숫자로 변환하여    
   결과 배열에 `push` 하면 된다.     
   
 <br>     
 <hr>    
   
 - 처음엔 비트가 나와서 비트 연산자를 가장 먼저 생각했었고, 그래서 `XOR (^)` 연산자를 활용하면     
   비트가 다를 때 1이 나오므로 1의 숫자가 2개 이하이면 f(x) 값이라고 생각했었다.     
   
 - 하지만 그렇게 되면, x보다 큰 숫자들을 모두 하나하나 다 살펴보고 연산해야 하는데,     
   그러기엔 x 의 범위가 `10^15` 였으므로 너무 비효율적인 방법이었다.    
   
 - 그래서 그런지 마지막 2개의 테스트 케이스(10,11번)가 계속 실패가 나왔었다.    
   비트 연산자 이외에도 하나하나 다 계산해야 하는 방법들은 마지막 2개의 케이스가 실패가 떴던 걸로 보아서    
   이런 문제는 완전탐색이 아닌 다른 방법을 찾아야한다는 걸 알 수 있었다.     
      

