## 2개 이하로 다른 비트    
- 풀이    

```javascript     
function solution(numbers) {
  var answer = [];
  for (n of numbers) {
    // 짝수라면 마지막이 무조건 0으로 끝나므로 +1 해주면 마지막 0이 1로 바뀌면서 
    // 1개만 다른 비트가 완성.
    // ex> 2 = 0010, 3 = 0011 / 16 = 10000, 17 = 10001
      if (n % 2 === 0) {
          answer.push(n+1);
      }
      // 홀수인 경우엔 여러번 직접 해보면서 규칙 찾기 
      // ex> 9 = 1001 , 10 = 1010 / 11 = 1011 , 13 = 1101 / 
            // => 9와 19은 마지막 01이 10으로 바뀌었고, 
            //    11과 13은 2~3번째 01이 10으로 바뀌었다. 
      // 15 = 1111 , 23 = 10111 / 21 = 10101, 22 = 10110 
            // => 15와 23의 경우엔 15 맨 앞에 0이 있다고 치면 맨 앞 01이 10으로 바뀌었다. 
            //    21과 22는 맨 마지막 부분의 01이 10으로 바뀌었다. 
      // 즉, 제일 끝에 나오는 01을 10으로 바꾸어주면 된다. 
      // indexOf가 아닌 lastIndexOf를 사용하는 이유는 최소값이기 때문인데 (= 2진수는 오른쪽으로 갈수록 작으므로), 
      // indexOf이면 21의 경우에 11001 로 25가 되기 때문이다.
      else {
          var bit = n.toString(2);
          var idx = bit.lastIndexOf('01');
      // 홀수는 마지막이 무조건 1로 끝나므로 01이 아닌 0을 찾아도 무관하다.
          // var idx = bit.lastIndexOf('0');
          var res = idx === -1 ? '10' + bit.substring(1) 
                      : bit.substring(0, idx) + '10' + bit.substring(idx+2)
        // 01을 못찾았다면 (-1 이라면), 1로만 이루어진 것이므로 앞에 0이 있다고 생각하고 111.. 을 1011.. 로 변경 
          // 즉, 맨 앞의 1를 떼버리고 대신 10을 붙이면 된다.
        // 01을 찾았다면, 0번부터 시작 idx 까지 자르고 대신 10을 붙이고 시작 idx +2번부터 다시 뒤에 붙이면 된다. 
        // substring은 인덱스가 문자열 길이를 넘어가면 알아서 마지막이라고 판단하기 때문에 길이는 신경안써도 ok  
          answer.push(parseInt(res,2));
        // 비트 계산 때문에 문자열이므로 다시 숫자로 바꿔서 answer 배열에 넣어준다.
      }
  }
  return answer;
}
```      
