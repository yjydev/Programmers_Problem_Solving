## 점프와 순간이동    
- 풀이   

```javascript    
function solution(n)
{
    var battery = 0;
    while (n){
        if (n%2) {
            n -= 1;
            battery += 1;
        } else {
            n /= 2;
        }
    }
    return battery;
}
```    

- 이번 문제는 `K 만큼 점프 (배터리 소모량 K)` 하거나 `(현재 이동 거리) X 2 만큼 순간이동 (배터리 소모 0)` 할 수 있는 수트를 입고,     
  배터리를 최소로 소모하여 N 만큼의 거리를 이동한다고 했을 때, 배터리 소모량을 리턴하는 문제이다.    
  
- 처음엔 `k만큼 이동`하거나 `x2 만큼 순간이동` 하는 2가지의 이동 방법이 있으므로 모든 경우의 수를 다 따져서    
  dfs 등의 완전탐색을 해봐야하나 싶었었는데, 주어진 조건에서 N 이 1 이상 1억 이하의 자연수여서    
  그렇게 풀 경우 시간초과가 될 것 같았다.    
  - 특히나 이번엔 효율성 테스트도 있었기 때문에 더욱 주의가 필요했다.     
  
- 고민하다가 다른 곳에서 약간의 힌트를 얻어서 생각해본 방법이, 어차피 점프는 `+k` 인거고, 순간이동은 `x2` 인 상황에서   
  배터리 소모량을 최소로 하려면 최대한 많이 순간이동을 하고 점프를 최소로 해야하므로 짝수인지 아닌지 구분해서 계산하는 것이었다.    
  
  - 즉, 짝수라면 순간이동으로 도달할 수 있는 거리인 것이고,     
    짝수가 아니라면 순간이동만으론 부족하므로 (+1) 만큼 점프도 해야하는 상황인 것이다.    

- 그래서 처음에 배터리 소모량을 저장할 변수 `battery` 를 0으로 초기화하고,     
  n 을 거꾸로 나누고 빼가면서 0이 될때까지 `while` 반복문을 돌린다.    
  - 만약 홀수라면, `n - 1` 을 하고 점프를 한거니까 `battery` 도 `+1`을 한다.    
  - 짝수라면, 순간이동으로 이동이 가능하므로 `n / 2` 를 하고, 순간이동이므로 `battery` 변수는 변하지 않는다.      


- 처음 짝수/홀수 구분 아이디어를 생각하기는 어려웠지만, 아이디어만 있다면 쉽게 풀 수 있는 문제였다.    
  

<hr>    

```javascript    
function solution(n)
{
    if (n === 1) return 1;
    var tmp = Array.from(n.toString(2));
    // var tmp = n.toString(2).split("");
    return tmp.reduce((a,b) => (+a)+(+b));
}
```    

- 풀이를 하고나서 다른사람들은 어떻게 풀었나 코드를 봤는데 굉장히 인상적인 코드가 있어서 가져와봤다.     
- 처음 아이디어 자체는 비슷한데, 짝수면 배터리 소모량이 없고 홀수면 `+1` 을 하는 규칙에서 착안한 것 같았다.    
- 즉, 2로 나눴을 때 `나머지가 0` 이면 `배터리 소모량도 0`이고, `나머지가 1`이면 `배터리 소모량도 1` 이므로    
  2진법을 대입하였다.    

- `toString` 메서드를 활용하여 2진법으로 만들고, `Array.from` 혹은 `split` 메서드를 통해 배열로 만든다.    
- 그리고 `reduce` 로 각 배열을 돌면서 현재 문자열로 이루어진 2진법을 모두 더하기 위해서 `+` 연산자를 통해 정수로 형변환을 하여 이전 값에 계속 더해준다.    
  - 2진법으로 0 이면 나머지가 0인 것이므로 순간이동 한 것이라 배터리 소모량이 0이다.    
  - 2진법으로 1이면 나머지가 1인 것이므로 점프한 것이라 배터리 소모량이 1이다.    


