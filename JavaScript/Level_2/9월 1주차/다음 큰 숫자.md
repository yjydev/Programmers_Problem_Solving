## 다음 큰 숫자    
- 풀이   

```javascript    
function solution(n) {
    var target = n.toString(2).match(/1/g).length;
    var cur = -1;
    while (true) {
        if (target === cur) return n;
        else {
            n += 1;
            cur = n.toString(2).match(/1/g).length;
        }
    }
}
```    

- 이번 문제는 1,000,000 이하의 자연수 n이 주어질 때, `n 보다 크면서` 2진수로 표현했을 때 n 과 `1의 개수가 같은 수`들 중 `가장 작은 수`를    
  리턴하는 문제였다.     
  
- 이전에 풀었던 [2개 이하로 다른 비트](https://github.com/yjydev/Programmers_Problem_Solving/blob/main/JavaScript/Level_2/2%EA%B0%9C%20%EC%9D%B4%ED%95%98%EB%A1%9C%20%EB%8B%A4%EB%A5%B8%20%EB%B9%84%ED%8A%B8.md) 문제와 유사하다고 느껴져서    
  처음엔 비슷하게 접근해보았다.    
  
- 일단 2진수로 표현했을 때 1의 개수가 같아야하므로 `toString(2)` 메서드를 활용하여 n을 2진수로 변환하였다.    

- 이전의 `2개 이하로 다른 비트` 문제에선 `n` 을 증가시키면서 2진수로 변환하고 비교하면 시간초과가 발생하였어서 규칙찾기를 했었는데,     
  이번 문제는 n의 범위가 훨씬 줄어든 `1,000,000` 이므로 n을 1씩 증가시키면서 1의 갯수를 비교하는 방식으로 풀어도 괜찮을 것 같았다.    
  
- 그래서 일단 `원래 n의 1의 갯수`를 `target` 변수에 저장해두고, `현재 n의 1의 갯수`를 담을 변수 `cur` 을 `-1`로 초기화한다.    

- 그 후, `while` 문을 돌면서 `target` 과 `cur` 이 같아지면 `n`을 리턴하고,   
  아니라면, `n`을 1씩 증가시키면서 `cur` 변수에 1의 갯수를 업데이트 한다.    
  
- 이전에 풀었던 문제의 영향인지 처음부터 너무 어렵게 생각하려고 했었어서 시간이 좀 더 걸렸던 것 같다.    
  - 다음부턴 문제 조건도 더 잘 살펴봐서 완전탐색을 해도 되는 문제인지 아닌지 잘 판단하면 풀이 시간을 더 줄일 수 있을 것 같다.      


<hr>    

- 이전 틀린 풀이    
  - [2개 이하로 다른 비트]의 풀이법으로 접근했던 풀이         

```javascript   
// 수정 필요, 1번 케이스만 실패 + 나머지 정확성, 효율성 모두 통과     
function solution(n) {
    var bin_n = n.toString(2);
    var idx = bin_n.lastIndexOf('01');
    bin_n = idx === -1 ? '10' + bin_n.substring(1)     
                       : bin_n.substring(0,idx)+'10'+ bin_n.substring(idx+2).split('').reverse().join('');
    return parseInt(bin_n,2);
}
```    

- [2개 이하로 다른 비트] 를 풀었던 것처럼 우선, 여러 숫자들을 변환해보면서 규칙을 찾고자 하였다.   
  - 15 (1111) => 23 (10111)    
  - 78 (1001110) => 83 (1010011)    
  - 90 (1011010) => 92 (1011100)     
  - 94 (1011110) => 103 (1100111)     
  - ...       

- 그러다보니 일단 해보았던 경우들에선 뒤에서부터 `01`을 찾아서 `10` 으로 변환하였고,     
  변환된 이후 자리들을 뒤집는다는 공통적인 규칙을 발견할 수 있었다.      
  
  - 즉 78 (1001 110) 의 경우엔, 뒤에서부터 `01`을 찾아서 `10` 으로 변환하고 (1010 110), 이후 자리를 뒤집으면 (1010 011) 로 83이 된다.     
  - 94 (1011 110) 의 경우엔, `01` 을 변환하면 (1101 110) 이 되고, 이후 자리를 뒤집으면 (1100 111) 로 103이 된다.    
  
    - 왜냐하면 2진수의 자릿수는 왼쪽으로 갈수록 `1, 2, 4, 8, 16, ...` 처럼 점점 커지는데     
      `01` 을 `10` 으로 바꾼다는 것은 2진수의 자릿수를 하나 키운다는 것이다. ( `010` => `011` => `100` )      
      
    - 원래 자릿수가 하나 증가하면 그 뒤는 모두 0이 될테지만, 지금은 1의 개수가 모두 동일해야하므로     
      최대한 오른쪽에 있는 자리부터 1을 채워가려다보면, 이후 자리를 뒤집는 것 같은 모양이 되는 것 같았다.      
      
 - 위와 같은 논리로 문제를 접근하여 풀었는데, 정확성 1번을 제외하곤 모두 맞았다. 왜 하나가 틀리는지는 조금 더 고민해봐야할 것 같다.    


  

