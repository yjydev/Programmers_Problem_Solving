## 다음 큰 숫자    
- 풀이   

```javascript   
// 수정 필요, 1번 케이스만 실패 + 나머지 정확성, 효율성 모두 통과     
function solution(n) {
    var bin_n = n.toString(2);
    var idx = bin_n.lastIndexOf('01');
    bin_n = idx === -1 ? '10' + bin_n.substring(1)     
                       : bin_n.substring(0,idx)+'10'+ bin_n.substring(idx+2).split('').reverse().join('');
    return parseInt(bin_n,2);
}
```    

- 이번 문제는 1,000,000 이하의 자연수 n이 주어질 때, `n 보다 크면서` 2진수로 표현했을 때 n 과 `1의 개수가 같은 수`들 중 `가장 작은 수`를    
  리턴하는 문제였다.     
  
- 이전에 풀었던 [2개 이하로 다른 비트](https://github.com/yjydev/Programmers_Problem_Solving/blob/main/JavaScript/Level_2/2%EA%B0%9C%20%EC%9D%B4%ED%95%98%EB%A1%9C%20%EB%8B%A4%EB%A5%B8%20%EB%B9%84%ED%8A%B8.md) 문제와 유사하다고 느껴져서    
  처음엔 비슷하게 접근해보았다.    
  
- 일단 2진수로 표현했을 때 1의 개수가 같아야하므로 `toString(2)` 메서드를 활용하여 n을 2진수로 변환하였다.    

- 그리고나서 여러 숫자들을 변환해보면서 규칙을 찾고자 하였다.   
  - 15 (1111) => 23 (10111)    
  - 78 (1001110) => 83 (1010011)    
  - 90 (1011010) => 92 (1011100)     
  - 94 (1011110) => 103 (1100111)     
  - ...       

- 그러다보니 일단 해보았던 모든 경우에선 뒤에서부터 `01`을 찾아서 `10` 으로 변환하였고,     
  변환된 이후 자리들을 뒤집는다는 걸 발견할 수 있었다.      
  
  - 즉 78 (1001 110) 의 경우엔, 뒤에서부터 `01`을 찾아서 `10` 으로 변환하고 (1010 110), 이후 자리를 뒤집으면 (1010 011) 로 83이 된다.     
  - 94 (1011 110) 의 경우엔, `01` 을 변환하면 (1101 110) 이 되고, 이후 자리를 뒤집으면 (1100 111) 로 103이 된다.    
  
    - 왜냐하면 2진수의 자릿수는 왼쪽으로 갈수록 `1, 2, 4, 8, 16, ...` 처럼 점점 커지는데     
      `01` 을 `10` 으로 바꾼다는 것은 2진수의 자릿수를 하나 키운다는 것이다. ( `010` => `011` => `100` )      
      
    - 원래 자릿수가 하나 증가하면 그 뒤는 모두 0이 될테지만, 지금은 1의 개수가 모두 동일해야하므로     
      최대한 오른쪽에 있는 자리부터 1을 채워가려다보면, 이후 자리를 뒤집는 것 같은 모양이 되는 것 같았다.      
      
 - 위와 같은 논리로 문제를 접근하여 풀었는데, 정확성 1번을 제외하곤 모두 맞았다. 왜 하나가 틀리는지는 조금 더 고민해봐야할 것 같다.    


  
