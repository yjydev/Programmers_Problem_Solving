## 다음 큰 숫자    
- 풀이   

```javascript    
function solution(n) {
    var target = n.toString(2).match(/1/g).length;
    var cur = -1;
    while (true) {
        if (target === cur) return n;
        else {
            n += 1;
            cur = n.toString(2).match(/1/g).length;
        }
    }
}
```    

- 이번 문제는 1,000,000 이하의 자연수 n이 주어질 때, `n 보다 크면서` 2진수로 표현했을 때 n 과 `1의 개수가 같은 수`들 중 `가장 작은 수`를    
  리턴하는 문제였다.     
  
- 이전에 풀었던 [2개 이하로 다른 비트](https://github.com/yjydev/Programmers_Problem_Solving/blob/main/JavaScript/Level_2/2%EA%B0%9C%20%EC%9D%B4%ED%95%98%EB%A1%9C%20%EB%8B%A4%EB%A5%B8%20%EB%B9%84%ED%8A%B8.md) 문제와 유사하다고 느껴져서    
  처음엔 비슷하게 접근해보았다.    
  
- 일단 2진수로 표현했을 때 1의 개수가 같아야하므로 `toString(2)` 메서드를 활용하여 n을 2진수로 변환하였다.    

- 이전의 `2개 이하로 다른 비트` 문제에선 `n` 을 증가시키면서 2진수로 변환하고 비교하면 시간초과가 발생하였어서 규칙찾기를 했었는데,     
  이번 문제는 n의 범위가 훨씬 줄어든 `1,000,000` 이므로 n을 1씩 증가시키면서 1의 갯수를 비교하는 방식으로 풀어도 괜찮을 것 같았다.    
  
- 그래서 일단 `원래 n의 1의 갯수`를 `target` 변수에 저장해두고, `현재 n의 1의 갯수`를 담을 변수 `cur` 을 `-1`로 초기화한다.    

- 그 후, `while` 문을 돌면서 `target` 과 `cur` 이 같아지면 `n`을 리턴하고,   
  아니라면, `n`을 1씩 증가시키면서 `cur` 변수에 1의 갯수를 업데이트 한다.    
  
- 이전에 풀었던 문제의 영향인지 처음부터 너무 어렵게 생각하려고 했었어서 시간이 좀 더 걸렸던 것 같다.    
  - 다음부턴 문제 조건도 더 잘 살펴봐서 완전탐색을 해도 되는 문제인지 아닌지 잘 판단하면 풀이 시간을 더 줄일 수 있을 것 같다.     
