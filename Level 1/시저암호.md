## 시저암호   
- 풀이 코드   

```python     
def solution(s, n):
    answer = ''
    for i in s:
        if ord(i) == 32:
            answer += ' '
        elif (65<=ord(i)<=90 and ord(i)+n > 90) or (97<=ord(i)<=122 and ord(i)+n > 122):
                answer += chr(ord(i)+n - 26)
        else :
            answer += chr(ord(i)+n)
    return answer
```    
- 알파벳을 n만큼 밀어야하므로 바로 아스키코드 생각이 났다.    
- 순간적으로 아스키코드 <=> 10진법 수 변환 함수가 가물가물했는데,    
  - `아스키코드 => 10진수` 는 `ord()` 함수이고,     
  - `10진수 => 아스키코드` 는 `chr()` 함수였다.    

- 공백은 아무리 밀어도 공백이므로 따로 처리해주고, 알파벳 소문자/대문자일때 각각 조건이 달라지므로     
  각각 `and` 연산자로 조건 걸고 `or` 연산자로 합쳤다.      
  - 만약, 범위를 벗어난다면 다시 돌아와야하므로 26만큼 빼주는 형식을 취했다.    


- 근데 다른 사람 풀이를 보니, `isupper()` 함수와 `islower()` 함수로 대소문자 여부를 판단할 수 있었던 것 같았다.     
  - 그리고, 현재 아스키코드를 구해서 알파벳 대소문자의 시작인 `A`, `a` 의 아스키코드와의 `차이`를 구하면 시작점부터 `현재 거리`이고,         

    n만큼 더하면, n만큼 `밀린 후의 거리`가 나오므로 이 때 26을 넘기지 않도록 `% 26` 으로 처리해주는 방법이 있다는 걸 알 수 있었다.          
    
    - 간단 코드   
      ```python    
      for i in s:
        if i.isupper():
           answer += chr(ord('A') + (ord(i)-ord('A')+n) % 26)     
      ```    
      - 소문자일 경우에도 비슷하게 `islower()` 함수로 이용하면 된다.        


- 나도 처음에 `%26` 을 사용해보려다가 더 깊게 못들어가고 노선을 틀었었는데,     

  다른 사람의 풀이를 보다보니 이렇게도 활용할 수 있구나라는 생각이 들었다.         
- 역시 일단 풀어본 다음, 다른 사람들은 어떻게 풀었는지 보는게 나중에라도 어디선가 도움이 될 것 같다는 생각이 들었다.      



