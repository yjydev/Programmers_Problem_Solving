## 폰켓몬   
- 풀이   

```python   
def solution(nums):
    max_pos = len(nums)//2
    # 연구실에 있는 폰켓몬의 종류가 가져갈수 있는 수보다 작다면, 연구실에 있는 폰켓몬을 종류별로 가져가면 최대    
    if len(set(nums)) < max_pos:
        return len(set(nums))
    # 연구실에 있는 폰켓몬의 종류가 가져갈 수 있는 수보다 많다면, 어차피 n//2 마리만 가져갈 수 있으므로
    else:
        return max_pos
```   
- 이번 풀이는 생각하다가 조금 헷갈려서 주석을 달아봤다.     
- 이번 문제는 연구실에 있는 폰켓몬을 가져갈 수 있는 한도 내에서 최대한 많은 종류로 가져가려고 할 때, 가져갈 수 있는 종류를 구하는 문제이다.    
- 처음엔 당연하게 `N//2` 마리의 조합을 구해서 그 중 종류가 가장 많은 것을 return 하면 되겠거니 생각해서 코드를 구현했는데,    
  실행 7번 이후엔 죄다 시간 초과 & 런타임 에러가 발생했다.      
  ```python  
    k = len(nums)//2
    res = set()
    def dfs(arr, n):
        if len(arr) == k:
            res.add(len(set(arr)))
        for i in range(n, len(nums)):
            dfs(arr+[nums[i]], i+1)
    dfs([],0)
  ```    
- 그래서 그냥 `dfs`가 아닌, `백트래킹`을 해야하는 건가 싶어서 백트래킹 조건을 고민하고 있었는데,    
  문득 깨달은 점이 있었는데, 어차피 가져갈 수 있는 수는 정해져있고, 연구실에 있는 폰켓몬의 종류도 정해져있다는 것이었다.        
  - 즉, 만약 연구실에 3종류의 폰켓몬이 있는데 가져갈 수 있는 폰켓몬이 4마리라면, 어차피 3종류 밖에 못데려간다는 것이다.    

- 그래서 백트래킹을 구현해보려던 것을 지우고 간단하게 연구실에 있는 폰켓몬의 종류가 `N//2` 보다 작다면 바로 return 하고,    
  아니라면, `N//2` 를 return 하는 방향으로 코드를 바꿔보니 바로 통과하는 것을 볼 수 있었다.    
- 이번 문제를 통해 단순히 조합 문제라고 조합을 구현하는게 능사가 아니고 문제를 더 자세하게 뜯어봐야 한다는 것을 알 수 있었다.   






