## 최대공약수와 최소 공배수   
- 풀이   

```python   
def solution(n, m):
    max_num = 0
    for i in range(1,min(n,m)+1):
        if n % i == 0 and m % i == 0:
            max_num = i        
    return [max_num,(n//max_num)*(m//max_num)*max_num]
```    
- 이번 문제는 주어진 두 수의 최대공약수와 최소공배수를 구하여 배열로 출력하는 문제였다.   
- 최대 공약수는 `두 수를 모두 나눌 수 있는 수 중 가장 큰 수`, 최소 공배수는 `두 수의 공통된 배수 중 가장 작은 수`를 뜻한다.    
- 정의에 따라서 코드를 구현하였는데, 1부터, 두 수 중 더 작은 수까지 순회를 돌면서 두 수를 동시에 나눌 수 있으면    
  최대 공약수를 갱신하는 형식으로 구했고,      
  최대 공약수가 구해지고 나면 최소 공배수는 `두 수를 최대 공약수로 나눈 수 * 최대공약수`로 구했다.   
  - 최대 공약수는 공약수 중 최대값을 구하는 것이고, 작은 수를 큰 수로 나눌 순 없으므로 두 수 중 작은 수까지를 범위로 잡았다.        
  - 최소 공배수는 일단 공배수를 구해야 하는데, 최대 공약수가 구해진 상황에서 각각의 두 수는     
    `최대공약수 * k`, `최대공약수 * l`과 다름없으므로 `k` 와 `l` 만 구해서 `최대공약수 * k * l`을 하면 된다.        
- 그리고 다른 사람 풀이를 보다보니까 `유클리드 호제법`으로도 구할 수 있었다는 걸 알 수 있었다.       
  ```python   
    def gcdlcm(a, b):
    c, d = max(a, b), min(a, b)
    while d:
        c, d = d, c % d
    answer = [c, int(a*b/c)]
    return answer
    ```        
    - 주어진 두 수에 대하여, 최대값 c, 최솟값 d 를 잡고 `c % d = 0` 이 될때까지 반복문을 돌게 된다.    
    - 만약 `a = 3`, `b = 12` 라면, `c = 12`. `d = 3` 이 된다.   
      - 첫 반복 때, c = 3, d = 0 이 되므로 반복이 종료되고,     
        answer에 최대공약수 `c = 3`, 최소공배수 `3*12/3=12` 이 담기게 된다.     
      - 현재 가정에선 두 수가 서로의 약수, 배수 관계이기 때문에 반복이 한 번만에 종료될 수 있었다.    
      - 이외의 경우에선, 최대값 c와 최솟값 d를 계속 갱신해가면서 c가 d로 나누어떨어질때까지 반복하게 된다.    

- 유클리드 호제법은 이전에 전공 공부할 때 배웠었다가 반쯤 까먹고 있었는데, 이번 문제 풀이를 계기로 가물가물하게나마 다시 생각이 나는 것 같았다.      

