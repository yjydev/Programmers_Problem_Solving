## 같은 숫자는 싫어   
- 풀이  

```python   
def solution(arr):
    prev = -1
    answer = []
    for k in arr:
        if k == prev:
            continue
        else:
            prev = k
            answer.append(k)
    return answer
```    
- 배열이 입력으로 들어올 때, 배열의 순서를 지키면서 **연속으로 중복**되는 숫자는 1개만 남게끔 제거하는 문제였다.    
- 처음엔 set 자료 구조로 변환했다가 다시 list로 변환하면 되지 않을까 싶었는데,    
  그렇게 되면 오름차순으로 정렬이 되어서 문제의 요구조건에 부합하지 않았다.   
- 두번째론, 입력 배열의 최대값을 구해서 그 수만큼의 길이를 가진 체크 배열을 만들어서 처음 나오면 체크한 후 정답에 넣고,  
  이미 체크가 되어있다면 넘어가는 방법을 생각했었다.   
  그렇게 되면 `1,1,0,1,1` 처럼 다른 숫자 다음에 들어오는 경우엔 모두 중복처리 되어 연속 중복만 처리해야하는 조건에    
  부합하지 않았다.   
  
- 그래서 최종적으론, 배열을 순회 돌면서 prev 라는 변수에 이전 값을 담아두고, 이전 값과 현재 값이 같다면 중복으로 처리하고     
  다르다면 prev 변수를 다시 업데이트 하는 방식으로 진행하여, 값에 초점을 두는 것이 아니라 연속 여부에 초점을 두었다.   
- 배열 내부의 숫자들이 0부터 9까지의 숫자이므로 prev 변수는 이외의 값이어야 해서 `-1`로 설정하였다.    
  
- 처음엔 중복 제거에만 꽂혀서 문제를 제대로 안 읽었던 것 같은데, 중복 제거가 중요한 것이 아니라, `연속되는 중복을 제거`하는 것이    
  핵심이었다.   
  이번엔 문제와 풀이가 간단하고 짧아서 문제없었지만, 만약 추후 문제가 복잡한 곳에서 이런 실수를 한다면      
  문제를 풀 시간이 부족해질 것 같아서, 문제를 세세하게 읽어서 한번에 정확하게 이해하는 것이 중요한 것 같다.    
